==========
Validation
==========

Lovely PyRest provides two ways of validation. On the one hand you can use
schema validation using `Validictory <https://github.com/sunlightlabs/validictory>`_. On the other hand you can implement
custom validators as functions to be more flexible.
Both ways can be combined.

Schema Validation
=================

This is an example how to validate the `query`-Parameter and the request body:

.. literalinclude:: examples/schema_validation.py

.. doctest::
    :hide:

    >>> app = get_app('testing.examples.schema_validation')

Performing a POST request without any body or GET-Parameter fails and a json
error gets returned::

    >>> res = app.post('/article', status=400)
    >>> print res.status
    400 Bad Request

    >>> print_json(res.body)
    {
        "errors": [
            {
                "description": "Required field 'id' is missing",
                "location": "query"
            },
            {
                "description": "No JSON object could be decoded",
                "location": "body"
            }
        ],
        "status": "error"
    }

For validation the `query` and `body` properties are used as seperate schemas.
The `query` schema is used for validating the GET-Parameter and the `body`
schema is used for validating the request body.
It's not necessary to define both of them.

.. note::

    If you define a `query` schema it's important that the type is `object`,
    because the GET-Parameter will be converted to a dictionary before they
    get validated.
    For the `body` schema it's ok to use `array`.


For schema validation `Validictory
<https://github.com/sunlightlabs/validictory>`_ is used.
Check the documentation to learn how to define schemas: `Validictory Documentation <http://validictory.readthedocs.org/en/latest/>`_.


Arrays on GET requests
----------------------

It is possible to validate arrays on GET parameters. The parameter string will
be split by commas and each tag will be used as a list value. This way it is
for example possible to validate against a list of allowed words::

    >>> res = app.get('/article?id=100&categories=news,music', status=400)
    >>> print res.status
    400 Bad Request

    >>> print_json(res.body)
    {
        "errors": [
            {
                "description": "Failed to validate field 'categories' list schema: Value u'music' for list item is not in the enumeration: ['news', 'sports', 'politics']",
                "location": "query"
            },
            {
                "description": "No JSON object could be decoded",
                "location": "body"
            }
        ],
        "status": "error"
    }


Validators
==========

This example shows how to implement `validators` as functions:

.. literalinclude:: examples/validation.py

.. doctest::
    :hide:

    >>> app = get_app('testing.examples.validation')

The `validator` function gets called by `lovely.pyrest` and passes the incoming
request as parameter.
The `validator` just has to add one or more errors if validation fails.
It's possible to use multiple validators.


    >>> res = app.get('/article', status=400)
    >>> print res.status
    400 Bad Request

    >>> print_json(res.body)
    {
        "errors": [
            {
                "description": "Parameter `id` is missing",
                "location": "query"
            }
        ],
        "status": "error"
    }

Nullable String
---------------

Lovely PyRest provides a custom 'nullable string' format validator by default.
Define a schema as follows to be able to assign 'null' to a parameter. The
format validator checks if the assigned value is a valid string
or none:

.. literalinclude:: examples/schema_validation_nullable_string.py

.. doctest::
    :hide:

    >>> app = get_app('testing.examples.schema_validation_nullable_string')

    >>> res = app.post_json('/article', {'title': 123}, expect_errors=True)
    >>> print res.status
    400 Bad Request

    >>> print_json(res.body)
    {
        "errors": [
            {
                "description": "'123' is not null or a string",
                "location": "body"
            }
        ],
        "status": "error"
    }
