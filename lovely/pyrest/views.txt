.. Shared Source Software
   Copyright (c) 2006-2013, Lovely Systems GmbH

===============
Views Unit Test
===============

lovely.pyrest provides some views and methods to create or decorate views.

Fallback View
=============

Every view of a `service` has some predicates. If pyramid receives a request
where none of the predicates matches pyramid will raise a PredicateMismatch
error and a `404` gets returned.
For example: If a service gets defined, which has one
view for `GET`, a `POST` request would cause a 404 because there is no view in
the service which matches the 'http_method' predicate.
Because a `405` error would be the correct error code for this case every service
has a default view which matches all predicates and returns better error views.
Let's define a service::

    >>> from lovely.pyrest.service import Service
    >>> service = Service('myService', '/service')

Method not allowed
------------------

Add a view::

    >>> @service.get()
    ... def get(request):
    ...     return 'hello'

Create the fallback view from the service::

    >>> from lovely.pyrest.views import get_fallback_view
    >>> fb = get_fallback_view(service)

The fallback view raises a `405` if the request method is not defined in the
`service`::

    >>> from pyramid.request import Request
    >>> from lovely.pyrest.errors import Errors
    >>> request = Request({})
    >>> request.errors = Errors()
    >>> request.method = 'POST'
    >>> res = fb(request)
    >>> print res.status
    405 Method Not Allowed

    >>> print_json(res.body)
    {
        "errors": [
            {
                "description": "The method POST is not allowed for this resource",
                "location": "method"
            }
        ],
        "status": "error"
    }

Unsupported Media Type
----------------------

Let's add a view for post with a `content_type` predicate::

    >>> @service.post(content_type='application/json')
    ... def post(request):
    ...     return 'hello'

The fallback view raises an error because the `content_type` field doesn't
match::

    >>> from lovely.pyrest.views import JSONError
    >>> res = fb(request)
    >>> print res.status
    415 Unsupported Media Type

    >>> print_json(res.body)
    {
        "errors": [
            {
                "description": "Content-Type header should be one of ['application/json']",
                "location": "header"
            }
        ],
        "status": "error"
    }


Decorated View
==============

The `decorate_view` method adds a decorator to a `pyramid` view. The decorator
validates the `schema` and executes the additional `validators`.
Create a view::

    >>> def my_view(request):
    ...     return 'hello'

Validator
---------

Create a validator which always fails and adds an error to the request::

    >>> def validate(request):
    ...     request.errors.add('location', 'error')
    ...     request.errors.status = 409

Perform a request on the not decorated view::

    >>> request = create_request()
    >>> my_view(request)
    'hello'

    >>> pprint(request.errors)
    []

If the request gets performed on the decorated view, the validator gets
executed::

    >>> from lovely.pyrest.views import decorate_view
    >>> decorated = decorate_view(my_view, {'validators':[validate]})
    >>> decorated(request)
    <JSONError ... 409 Conflict>

    >>> pprint(request.errors)
    [{'description': 'error', 'location': 'location'}]

Schema
------

Create a schema::

    >>> schema = {
    ...     "query": {
    ...         "type": "object",
    ...         "properties": {
    ...             "u": {
    ...                 "type": "string",
    ...                 "format": "url"
    ...             }
    ...         }
    ...     }
    ... }

Create a decorated view with the schema::

    >>> decorated = decorate_view(my_view, {'schema':schema})

Perform a request on the not decorated view::

    >>> request = create_request()
    >>> my_view(request)
    'hello'

    >>> pprint(request.errors)
    []

If the request gets performed on the decorated view the schema gets validated::

    >>> decorated(request)
    <JSONError at ... 400 Bad Request>

    >>> pprint(request.errors)
    [{'description': "Required field 'u' is missing", 'location': 'query'}]

JSONP
-----

We enabled JSONP by default by setting the default renderer to `jsonp`.
If you create a view you do not have to set anything specific.
If the request has set a query parameter `callback=my_callback`
the JSONP transformation will be triggered.
Note: The name of the parameter name `callback` can be specified in the .ini
file of the app which uses lovely.pyrest using
`lovely.pyrest.jsonp.param_name = your_callback_function_name`.
If you do not specify the parameter `lovely.pyrest.jsonp.param_name` the value
will be set to the default `callback`.

If you want to disable the JSONP support for a specific view, you need to
specify a different renderer (e.g. `renderer='json'`)

Create an undecorated view::

    >>> def my_view(request):
    ...     return {'data': 'some test data'}

Disable the JSONP support and create a decorated view::

    >>> renderer = 'json'
    >>> decorated = decorate_view(my_view, {'renderer': renderer})

Perform a request on the decorated view with query parameter
`callback=my_callback`. JSONP support is disabled.
Therefore, the transformation is not triggered::

    >>> request = create_request()
    >>> request.GET['callback'] = 'my_callback'
    >>> decorated(request)
    {'data': 'some test data'}

Help Support
------------

If a request contains the query parameter `help` the defined `schema` will be
displayed as a documentation to show which query parameters can (or must)
be present in a request.
This feature is enabled by default. This feature can be turned off for each
view by setting `help` to `False`

If and API endpoint does not accept any query parameters (i.e. schema is
empty) an appropriate message will be returned.

Create an undecorated view::

    >>> def my_view(request):
    ...     return {'data': 'awesome test data'}

Decorate the view without a schema::

    >>> schema = {}
    >>> decorated = decorate_view(my_view, {'schema': schema})

Perform a request on the decorated view with the query parameter
`help`. The response should state that no specific query parameters
are required.

    >>> request = create_request()
    >>> request.GET['help'] = ''
    >>> decorated(request)
    {'help': 'This API endpoint does not accept any specific query parameters'}

Decorate the view with a schema::

    >>> schema = {
    ...     "query": {
    ...         "type": "object",
    ...         "properties": {
    ...             "param1": {
    ...                 "type": "string",
    ...                 "format": "url",
    ...             },
    ...             "param2": {
    ...                 "type": "string",
    ...                 "format": "url",
    ...                 "required": False
    ...             }
    ...         }
    ...     }
    ... }
    >>> decorated = decorate_view(my_view, {'schema': schema})

Perform a request on the decorated view with the query parameter
`help`. The schema should be responded as help.

    >>> request = create_request()
    >>> request.GET['help'] = ''
    >>> decorated(request)
    {'query': {'type': 'object', 'properties': {'param2': {'required': False, 'type': 'string', 'format': 'url'}, 'param1': {'type': 'string', 'format': 'url'}}}}


Decorate a view with the same schema as before and turn off the help function.
The same request as before will be used. The `help` query parameter is set.
Now, the request is validated again even if the query parameter `help`
is set because the help function is turned off::

    >>> decorated = decorate_view(my_view, {'schema': schema, 'help': False})
    >>> response = decorated(request)
    >>> response.status
    '400 Bad Request'
    >>> request.errors
    [{'location': 'query', 'description': "Required field 'param1' is missing"}]

